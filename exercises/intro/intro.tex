\documentclass[a4paper,10pt]{article}
\setlength{\parindent}{0ex}
\setlength{\parskip}{1.5ex}
\usepackage[dvips]{graphicx}
\usepackage{epsfig}
\usepackage[a4paper, hmargin=25mm, vmargin=30mm, nohead]{geometry}

\usepackage{fancyhdr}
\fancypagestyle{rcsfooters}{
\fancyfoot[L]{\small $ $RCSfile: intro.tex,v $ $}
\fancyfoot[R]{\small $ $Revision: 1.9 $ $}
}

\renewcommand{\headrulewidth}{0pt}

%INCLUDE OUR GLOBALS
\usepackage{rex201}
\usepackage{styles201}
\usepackage{ex201}


\begin{document}

\EXHEADING{\INTRONO}{\INTROTITLE}{%
Verification Date:~\INTRODUE\\
Excercise Test Date:~\TESTONEDATE\\
}


\section{Assessment}
To show that you have completed this exercise to a satisfactory
standard you will be required to demonstrate at a verification session
that the program you wrote in \textbf{Question~\ref{ques:final}} 
of this exercise
runs correctly. In addition the marker may ask one or two questions so
they establish that you understand what you have done.  These
verification sessions will be held in \ASSESSROOM\ during the following two
times:

\begin{itemize}
\item \INTRODUE~\MORNINGASSESS
\item \INTRODUE~\AFTERNOONASSESS 
\end{itemize}

In an attempt to ensure that the verification process runs smoothly
six machines in \ASSESSROOM\ will be booked for this purpose during the two
sessions. When it is your turn to have your program verified you
should log onto one of these machines and get your program ready to
run on the REX board. A marker will then verify your program. Once
your program has been verified you should log off immediately to allow
the next person to prepare to have their program verified.

In addition to the test there will be a closed book excercise test on
\textbf{\TESTONE}.  The test will cover material 
from excercises 1, 2 and 3.

The tutorial times are listed on the course webpage:

\begin{center}
\src{\WEBPAGEBASE}
\end{center}

\section{Objectives}
The objective of this exercise is to familiarise 
yourself with writing, assembling, linking, running, and
debugging assembly code for the WRAMP processor and the REX board.

Before attempting this excercise you should have read the 
chapter `Introduction to Rex and WRAMP' in your course manual.  The material covered in this chapter of the manual \textbf{is examinable}.

The I/O routines you should use in this exercise are contained in the
file \LIBEXTWOP. These routines are outlined in Appendix
\ref{app:ioroutines}.

\section{Questions}
\begin{enumerate}
\item\label{ques:first} Write a program which continually (i.e. is in
an infinite loop) reads the values on the switches and outputs the
value read to the two seven segment displays.  For example if the
switches are set to the pattern shown in Figure \ref{fig:switches} the
two seven segment displays should show \src{92}.

\item\label{ques:two} Modify your program in Question \ref{ques:first}
to continually output the number of switches currently set (in the
down position or one) to the seven segment display. For example if the
switches are set to the pattern shown in Figure \ref{fig:switches}
then the seven segment display should display \src{03}.

\item\label{ques:final} Modify the program written in Question
\ref{ques:two} to encrypt the count of set switches before outputting
it to the seven-segment display. The encryption algorithm to be
applied is the very simple mapping function defined in Table
\ref{table:encode}. For example, the value \src{4} encrypted would be
displayed as \src{05}, and the value \src{8} encrypted would be
displayed as \src{07}.
\end{enumerate}

\begin{figure}[!hb]
\begin{center}
%\begin{tabular}{|c|}
%\hline
\includegraphics[width=10cm]{switches.eps}
%\\
%\hline
%\end{tabular}
\caption{Example}
\label{fig:switches}
\end{center}
\end{figure}


\begin{table}[h]
\begin{center}
\begin{tabular}{|c|c|}
\hline
\verb|       |0\verb|       | & \verb|       |1\verb|       | \\ \hline
1 & 0 \\ \hline
2 & 8 \\ \hline
3 & 2 \\ \hline
4 & 5 \\ \hline
5 & 4 \\ \hline
6 & 9 \\ \hline
7 & 3 \\ \hline
8 & 7 \\ 
\hline
\end{tabular}
\end{center}
\caption{Mapping Function for Encryption Process}
\label{table:encode}
\end{table}

\newpage
\appendix
\section{I/O Routines}
\label{app:ioroutines}

\begin{description}
\item \textbf{putch} 
The subroutine outputs a single ASCII character to the
terminal. The character to be output is passed in register \reg{2}.

\item \textbf{putstr} 
The subroutine outputs a null terminated string to the
terminal. The address in memory of the first character in the string
is passed to the subroutine in register \reg{2}. Uses printf so any
percentage signs may cause unexpected side-effects.

\item \textbf{readnum} 
Subroutine to read a decimal integer number from the keyboard
and convert it to 32 bit 2's compliment number. Number is echoed to
terminal. The subroutine exits when a non-digit character is entered
and returns the number read in register \reg{1}.

\item \textbf{writenum} 
Subroutine to write a 32 bit 2's compliment number to the
terminal as a decimal integer number. The number to output is passed
in register \reg{2}.

\item \textbf{readswitches} 
When called this subroutine returns, in register
\reg{1}, the current value on the switches in the low order bits (0 to
7). Bits 8 through 31 of \reg{1} are cleared (set to zero) by this
subroutine. For example if the subroutine is called with the switches
set in the pattern shown in Figure 3 then \reg{1} will contain 0x00000092
when the subroutine returns.

\item \textbf{writessd}
When called this subroutine will display the lowest
order byte (bits 0-7) of register \reg{2} as a pair of hexadecimal digits
to the seven segment displays. For example if \reg{2} contains 0x0000005a
when the subroutine is called then ``5a'' will be displayed on the
seven-segment displays.

\item \textbf{exit}
This is a non-returning subroutine that when called returns
control back to the monitor.
\end{description}



\thispagestyle{rcsfooters}
\pagestyle{rcsfooters}
\end{document}
