\documentclass[a4paper,10pt]{article}
\setlength{\parindent}{0ex}
\setlength{\parskip}{1.5ex}

\usepackage[dvips]{graphicx}
\usepackage{epsfig}
\usepackage{verbatim}

\usepackage[a4paper, hmargin=25mm, vmargin=30mm, nohead]{geometry}

%INCLUDE OUR GLOBALS
\usepackage{rex201}
\usepackage{styles201}
\usepackage{ex201}

\begin{document}

\EXHEADING{\RTLSIMNO}{\RTLSIMTITLE}{Final Verification Date: \RTLSIMDUE\\}

\section{Objective}

The purpose of this exercise is to reinforce the ideas presented in
the lectures on Machine Architecture. To achieve this you are going to
act as the control unit for a WRAMP processor similar to the one
presented in lectures. Using this simulator you will execute three
separate sequences of instructions and submit a log of each of the
runs to a marking program.

\section{Verification}

To show that you have completed this exercise to a satisfactory
standard you will be required to submit correct simulator histories
for all three code sequences to the marking program. You will receive
an attempted grade for this exercise if you submit correct histories
for the first two sequences.


\section{Introduction}

Figure~\ref{fig:datapath} shows the architecture of the WRAMP
CPU that contains three 32 bit internal buses. Although not shown on
the diagram there are control lines between the control unit and each
of the components, which are used to control the flow of data on the
datapath. The control signals for each of the components and their
functionality is defined in Table~\ref{table:signals}.

\begin{figure}[h]
  \begin{center}
    \psfig{figure=datapath.eps, width=.8\linewidth}
    \caption{WRAMP Architecture Datapath}
    \label{fig:datapath}
  \end{center}
\end{figure}

To allow you to act as the control unit for this simple architecture
you are going to use a simulator (called \program{wrampsim}). When
using the simulator you will repeatedly set all of the signals
required to implement a control step and then the simulator will use
these signals to perform the operations you have requested. By
performing a sequence of such control steps it is possible to fetch
instructions from the simulated machine's memory and execute them. To
allow real WRAMP machine code to be stored in the memory of this
simulated machine, the simulator has a feature to read S-record files,
generated by the standard \program{wasm} and \program{wlink} commands,
into its memory. Also when you use the simulator a history of all of the
signals set in each control step is recorded which can be saved into a
file. These histories are submitted to a marking program so that you can
have each of the sequences verified.

You should note that semantics and encoding of each of the
instructions in the three code sequences that follows is identical to
those used in the actual WRAMP CPU. In fact the S-record that you will
use for each of the three code sequences can be uploaded to a REX
board and executed. You may find this a useful exercise to help verify
that you are simulating the correct behavior in the simulator.

\section{Sequence One}

The purpose of the first sequence of the instructions is to
demonstrate the operation of the \texttt{wrampsim} simulator and the
Web based marking program.

The WRAMP source code for the first sequence is shown in
Figure~\ref{fig:seq1}.

\begin{figure}[h]
\begin{footnotesize}
\begin{center}
\begin{tabular}{|p{7cm}|}
\hline
\begin{verbatim}
       .text
       .global main
       main: 
             addui    $3, $0, 2002
             syscall
\end{verbatim}
%%$
\\
\hline
\end{tabular}
\end{center}
\end{footnotesize}
\caption{WRAMP source code for first sequence}
\label{fig:seq1}
\end{figure}

Instructions to execute the first sequence on \program{wrampsim} are as
follows:

\begin{enumerate}

\item Create a directory to store the files created in this exercise
in and change to this directory.

\item Start the simulator by typing the command \program{wrampsim} at
a command prompt.

\item Display the Memory, Register and History windows by selecting
each one individually from the ``View'' menu. These windows give you
extra information about the state of the simulator.

\item Load the memory image for this part of the assignment into the
memory of the simulator. To do this you will need to load the S-record
for the sequence using the ``Load S-Record'' option found in the
``File'' menu. This should pop up an open file dialog. You should load
the file \filename{ex5\_1.srec} from the \filename{/home/201/ex5}
directory. The source code for this file can be found in the
\filename{ex5\_1.s} file in the same directory. You should see the first
two memory locations in the ``Memory'' window change to the assembled
version of the above instructions.

\item 
\label{ques:ifetch}
You are now ready to start executing your first instruction. This
instruction must first be loaded from memory into the Instruction
Register (IR) of the machine. This can be achieved by setting the
\src{pc\_out}, \src{mem\_read} and \src{ir\_in} signals in
the output signals section. Notice that the colours of the buses and
components change as you do this. Once these signals are set then
click on the ``Cycle'' button below the signals. The cycle button
instructs the simulator to perform the operation. After this the
contents of the IR should change to reflect the instruction that has
just been fetched. Also notice that the instruction has been
disassembled and displayed in the ``Feedback Signals'' section.

\item Before you can execute the instruction you have fetched you will
need to increment the program counter. This leaves the program counter
pointing at the next instruction to be executed. You may wish to first
unset all of the previous output signals. A ``Clear'' button is
provided to allow this to be done quickly. To increment the PC you
need to set the \src{pc\_out}, \src{alu\_out},
\src{alu\_func=inc} and \src{pc\_in} signals and click on the
``Cycle'' button. There should now be two lines of signals in the
history window. One line of signals is added to the history each time
you press the ``Cycle'' button. A line represents shows what signals
were set when you pressed the ``Cycle'' button.

\item The last stage is to execute the instruction itself. This
instruction is an add unsigned immediate instruction. The result of an
\src{addui} is to add the value stored in the instruction, in this
case 0x7d2, together with the contents of Rs (\reg{0}) and place
the result into \regd (\reg{3}). For a full explanation of all ALU
functions refer to the ALU operations in table~ref{table:alu}. The
instruction can be run by setting \src{a\_out},
\src{sel\_a=\$0}, \src{imm\_16\_out}, \src{alu\_out},
\src{alu\_func=addu}, \src{c\_in}, \src{sel\_c=\$3}. Click on
the ``Cycle'' button to complete the operation. Check that the value
in \reg{3} in the register window contains the value you expect
it to.

\item You will now need to fetch the second instruction. You could
simply repeat the steps shown in part~\ref{ques:ifetch}, however
\program{wrampsim} provides a facility for reusing sets of signals that
you have used before. To do this you can double click on a line in the
``Operation History'' window and the signals will be set to the same
as they were in that line of the history. Double click on the first
line of signals and click ``Cycle'' to perform the second instruction
fetch after validating that the signals are set appropriately.

\item You must \textit{always} increment the PC immediately after you
execute an instruction fetch. The marking program will ensure that
this is the case before it will pass your submission. To increment the
PC, double click on the second set of signals in the ``Operation
History'' window and click ``Cycle''.

\item The next instruction is a \src{syscall}. In terms of this
exercise we consider this instruction to be the end of the sequence
and do \textit{not} execute it. For all three sequences, once you have
fetched the \src{syscall} and have incremented the PC you are
finished and should save and submit your work.

\item Save the history using the ``Save History'' option in the ``File
Menu''. Make sure you save the file somewhere you can find it again to
submit it to the marking system.

\item Load the following Web page :

\filename{http://lab1-1.cs.waikato.ac.nz/\~{}mpearson/ex5\_submit.html}

First enter your username and select the sequence 1 check box and
browse to find the history you just saved. Click the submit button to
submit your history.

\item All going well you will be notified if you executed the sequence
successfully. If you have then you should proceed onto the second
sequence. Otherwise read the message provided by the marking program
and correct your sequence. You may wish to play with the undo features
of the simulator to make changing your sequence easier. You may submit
all sequences of this exercise as many times as required to pass the
sequence.

\item Once you are happy that you have completed the first sequence
you can click on the ``Reset'' button to reset the machine to it's
original state in preparation for the next sequence.

\end{enumerate}

\newpage
\section{Sequence Two}

The second sequence contains five instructions that are mostly
arithmetic and memory instructions as shown in Figure~\ref{fig:seq2}.
The S-record file for this sequence can be found in
\filename{/home/201/ex5/ex5\_2.srec}. You should load it into the
simulated machines memory and execute the instructions (again with you
acting as the machines controller). As before, once you have fetched
the \src{syscall} instruction and incremented the PC you have
finished the sequence. You should then submit the trace file to the
web based marking program.

\begin{figure}[h]
\begin{footnotesize}
\begin{center}
\begin{tabular}{|p{7cm}|}
\hline
\begin{verbatim}
       .text
       .global main
       main:
             addui    $2, $0, 201
             lw       $3, sum($0)
             add      $4, $2, $3
             sw       $4, sum($0)
             syscall

       .data
       sum:
             .word    657
\end{verbatim} 
%%$
\\
\hline
\end{tabular}
\end{center}
\end{footnotesize}
\caption{WRAMP source code for second sequence}
\label{fig:seq2}
\end{figure}  

\section{Sequence Three}

This third sequence contains a series of branch and jump instructions
as shown in Figure~\ref{fig:seq2}. The S-record can be found in
\filename{/home/201/ex5/ex5\_3.srec}. Once you have managed to
successfully execute this sequence of instructions you should submit
the history file to the web based marking program.

\begin{figure}[h]
\begin{footnotesize}
\begin{center}
\begin{tabular}{|p{7cm}|}
\hline
\begin{verbatim}
       .text
       .global main
       main:
             ori      $4, $0, 14
             addui    $5, $0, 0x16
             sne      $3, $4, $5
             bnez     $3, okay

       forever:	
             j  forever

       okay:
             jal      add_two
             syscall

       add_two:
             add      $2, $4, $5
             jr       $ra
\end{verbatim}
%%$
\\
\hline
\end{tabular}
\end{center}
\end{footnotesize}
\caption{WRAMP source code for third sequence}
\label{fig:seq3}
\end{figure}
\newpage
\begin{table}[h]
\begin{center}
\begin{tabular}{|l|l|p{8cm}|}
\hline
\textbf{Component} & \textbf{Signal Name} & \textbf{Description} \\
\hline
Register File & \texttt{a\_out} & Causes the contents of the
register selected by \texttt{sel\_a} to be output onto the A bus. \\
\cline{2-3}
& \texttt{sel\_a} & Select which register will be output onto the A bus
if \texttt{a\_out} is asserted. \\
\cline{2-3}
& \texttt{b\_out} & Causes the contents of the
register selected by \texttt{sel\_b} to be output onto the B bus. \\
\cline{2-3}
& \texttt{sel\_b} & Select which register will be output onto the B bus
if \texttt{b\_out} is asserted. \\
\cline{2-3}
& \texttt{c\_in} & Causes the value from the C bus to be written
into the register selected by \texttt{sel\_c}.\\
\cline{2-3}
& \texttt{sel\_c} & Select which register to write the value from the C
bus into when the \texttt{c\_in} signal is asserted. \\
\hline
ALU & \texttt{alu\_out} & Causes the result of the current ALU function 
selected by \texttt{alu\_func} to be output to the C bus. \\
\cline{2-3}
& \texttt{alu\_func} & Defines the current operation that the ALU
should perform. ALU functions are defined in table~\ref{table:alu}. \\
\hline
Memory Interface & \texttt{mem\_read} & Causes the contents of the
memory address specified on the A bus to be read and output onto the C
bus. \\
\cline{2-3}
& \texttt{mem\_write} & Causes the value on the B bus to be written
into the memory address specified on the A bus. \\
\hline
Program Counter & \texttt{pc\_out} & Causes the contents of the PC
register to be output onto the A bus. \\
\cline{2-3}
& \texttt{pc\_in} & Causes the value on the C bus to be written into
the PC. \\
\hline
Instruction Register & \texttt{imm\_16\_out} & Causes the least
significant 16 bits of the IR to be output onto the B bus. \\
\cline{2-3}
& \texttt{imm\_20\_out} & Causes the least
significant 20 bits of the IR to be output onto the B bus. \\
\cline{2-3}
& \texttt{sign\_extend} & Causes the output from the IR to be sign
extended to 32bits. \\
\cline{2-3}
& \texttt{ir\_in} & Causes the value on the C bus to be written into
the IR. \\
\hline
Temporary Register & \texttt{temp\_out} & Causes the contents of the
temporary register to be output onto the A bus. \\
\cline{2-3}
& \texttt{temp\_in} & Causes the value on the C bus to be written into
the temporary register. \\
\hline
\end{tabular}
\end{center}
\caption{Descriptions of each of the control signals}
\label{table:signals}
\end{table}
\newpage
\begin{table}[h]
All arithmetic and test/set instructions have both signed and unsigned
variants. The unsigned variant is indicated by an instruction with a
'u' suffix. A singed variant treats all inputs as signed integers while
the unsigned variant treats inputs as unsigned integers.

\begin{center}
\begin{tabular}{|l|l|l|p{75mm}|}
\hline
\textbf{Type} & \textbf{Name} & \textbf{Function} 
& \textbf{Description} \\
\hline
Arithmetic & \texttt{add, addu} & A + B & Perform an integer
addition between A and B. \\
\cline{2-4}
& \texttt{sub, subu} & A - B & Perform an integer
subtraction between A and B. \\
\cline{2-4}
& \texttt{mult, multu} & A * B & Perform an
integer multiplication between A and B. \\
\cline{2-4}
& \texttt{div, divu} & A / B & Perform an integer
division between A and B. \\
\cline{2-4} 
& \texttt{rem, remu} & A $\bmod$ B & Obtain the remainder from an
integer division between A and B. \\
\hline
Bitwise & \texttt{sll} & A $<<$ B & Shift the value on A left by the number of
places specified by B. Fill with zeros. \\
\cline{2-4}
& \texttt{and} & A AND B & Perform a bitwise AND between A and B. \\
\cline{2-4}
& \texttt{srl} & A $>>$ B & Shift the value on A right by the number of places
specified by B. Fill with zeros. \\
\cline{2-4}
& \texttt{or} & A OR B & Perform a bitwise OR between A and B.\\
\cline{2-4}
& \texttt{sra} & A $>>$ B & Shift the value on A right by the number of places
specified by B. Fill with MSB.\\
\cline{2-4}
& \texttt{xor} & A XOR B & Perform a bitwise XOR between A and B. \\
\hline
Test/set & \texttt{slt, sltu} & out = 1 if ( A $<$ B) & Set out if A
is less than B\\
& & else out = 0 & \\
\cline{2-4}
& \texttt{sgt, sgtu} & out = 1 if ( A $>$ B) & Set out if A
is greater than B \\
& & else out = 0 & \\
\cline{2-4}
& \texttt{sle, sleu} & out = 1 if ( A $\le$ B) & Set out if A
is less than or equal to B\\
& & else out = 0 & \\
\cline{2-4}
& \texttt{sge, sgeu} & out = 1 if ( A $\ge$ B) & Set out if A
is greater than or equal to B\\
& & else out = 0 & \\
\cline{2-4}
& \texttt{seq, sequ} & out = 1 if ( A $=$ B) & Set out if A
is equal to B \\
& & else out = 0 & \\
\cline{2-4}
& \texttt{sne, sneu} & out = 1 if ( A $\neq$ B) & Set out if A
is not equal to B \\
& & else out = 0 & \\
\hline
Misc & \texttt{lhi} & out\tiny$_{[31...16]}$\normalsize~= B\tiny$_{[15...0]}$ &
Set the upper 16 bits of out to be the lower 16 \\
& & out\tiny$_{[15...0]}$\normalsize~= 0 & bits of B. Lower 16 bits of out set to zero. \\ 
\cline{2-4}
& \texttt{inc} & out = A + 1 & Increment A\\
\hline
\end{tabular}
\end{center}
\caption{ALU Operations}
\label{table:alu}
\end{table}


\end{document}