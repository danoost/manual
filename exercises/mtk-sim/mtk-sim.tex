\documentclass[a4paper,10pt]{article}
\setlength{\parindent}{0ex}
\setlength{\parskip}{1.5ex}
\usepackage[dvips]{graphicx}
\usepackage{epsfig}
\usepackage[a4paper, hmargin=25mm, vmargin=30mm, nohead]{geometry}

\usepackage{fancyhdr}
\fancypagestyle{rcsfooters}{
\fancyfoot[L]{\small $ $RCSfile: mtk-sim.tex,v $ $}
\fancyfoot[R]{\small $ $Revision: 1.1 $ $}
}

%INCLUDE OUR GLOBALS
\usepackage{rex201}
\usepackage{styles201}
\usepackage{ex201}

\renewcommand{\headrulewidth}{0pt}

\begin{document}

\EXHEADING{\MTKSNO}{\MTKSTITLE}{Verification Date:~\MTKSDUE\\}

\section{Assessment}

Complete the online verification linked of the class home page or
at:
\begin{center}\verb+http://lab1-1.cs.waikato.ac.nz/~mpearson/ex8test.html+\\
\end{center}
You must get 10/12 in this verification.

There is no test for this exercise but to complete the next exercise
(the WRAMP implementation of a multitasking kernel) you must
understand this material well.  This material will be assessed in the
final exam.

\section{Objective}

The purpose of this exercise is to provide an introduction to the way
a multitasking operating system operates. This exercise uses a simple
multitasking kernel simulator to execute pseudo-code sequences. In
combination with the lectures on multitasking kernels this exercise
aims to provide an introduction on the topic before the actual WRAMP
implementation of a multitasking kernel.

\section{Introduction} 

The aim of this exercise is to show the way that the CPU is
allocated to a particular process by the dispatcher. The exercise
includes pseudo-code for a number of operating system routines and
three simple user tasks.  By observing a simulator that
executes this code you will become familiar with the way that the
parts of a multitasking kernel interact.

\section{The Code}
The following sections contain the pseudo-code for the various parts
of the system and any notes as appropriate. Statements are numbered in
each section starting from 1.  Each section is also assigned a letter
to allow you to refer to a statement unambiguously.  

\newpage

\subsection{Dispatcher}
\renewcommand{\theenumi}{D\arabic{enumi}}
\subsubsection{Pseudo-code}
\textsf{
 \begin{enumerate}
  \setlength{\itemsep}{0cm}
  \item Add the suspended process to the CPU wait queue
  \label{disp-start}
  \item Save general registers in PCB
  \label{disp-save}
  \item Save return address (\texttt{\$ear}) in PCB
  \item Save old interrupt status in PCB
  \item Add \texttt{time\_slice\_counter} to \texttt{time\_used}
  \label{disp-select}
  \item Set \texttt{time\_slice\_counter} to \texttt{0}
  \label{tsc=0}
  \item Remove the first item from the CPU wait queue and
        make it the \texttt{current\_job}
  \item Load the CPU registers from the PCB
  \item Load the old interrupt status from the PCB
  \item Load the return address from the PCB
  \item Execute a return from exception (\texttt{'rfe'})
\end{enumerate}
}

\subsection{The Exception Handler}
\renewcommand{\theenumi}{H\arabic{enumi}}
\subsubsection{Pseudo-code}
\textsf{
 \begin{enumerate}
  \setlength{\itemsep}{0cm}
  \item If software interrupt jump to the dispatcher, \ref{disp-save}
  \item Increment the \texttt{time\_slice\_counter}
  \item If \texttt{time\_slice\_counter} is equal to \texttt{time\_slice}
        jump to the dispatcher, \ref{disp-start}
  \item Return from the interrupt
  \label{handler-return-disp}
 \end{enumerate}
}

\subsubsection{Notes}
\begin{itemize}
\setlength{\itemsep}{0cm}

\item When an exception occurs the branch to the exception handler is
      like a procedure call, in that the location to return to must be
      saved. In our example this is done by storing it in the
      \texttt{\$ear} register.

\item If the interrupted process is to execute without disturbance
      from the exception routine, then the exception routine must not alter any of
      the registers used by the interrupted process. In this exercise, this
      fact is hidden by the use of pseudo-code. In a real example this could
      be achieved by saving (some of) the registers to memory when the
      interrupt occurs and restoring them during the return from interrupt,
      or by having a separate set of registers for the interrupt routine to 
      use.
\end{itemize}

\newpage 

\subsection{Wait(sem)}
\renewcommand{\theenumi}{W\arabic{enumi}}
\subsubsection{Pseudo-code}
\textsf{
 \begin{enumerate}
  \setlength{\itemsep}{0cm}
  \item Disable interrupts
  \item Increment \texttt{sem.counter}
  \item If \texttt{sem.counter} is less than \texttt{1} then jump to
        \ref{wait-return-disp}
  \item Add the PCB for the current job to the queue for \texttt{sem}
  \item Generate a software exception
  \item Enable interrupts
  \label{wait-return-disp}
  \item Return from the wait call
  \end{enumerate}
}

\subsubsection{Notes}
\begin{itemize}
\setlength{\itemsep}{0cm}
\item Interrupts that occur while interrupts are disabled will normally
      be serviced when interrupts are enabled again.
\item `Wait' and `Signal' are subroutines. When they are called the address
      of the instruction following the call instruction is placed onto 
      the stack of the calling process.  When the return occurs this 
      address is popped off the stack and loaded into the PC. 
\item `Wait' and `Signal' both have a parameter (sem).  This parameter
      will be put on the stack before the subroutine is called.
\end{itemize}

\subsection{Signal(sem)}
\renewcommand{\theenumi}{S\arabic{enumi}}
\subsubsection{Pseudo-code}
\textsf{
 \begin{enumerate}
  \setlength{\itemsep}{0cm}
  \item Disable interrupts
  \item Decrement \texttt{sem.counter}
  \item If \texttt{sem.counter} is less than \texttt{0} then jump to
        \ref{signal-return-disp}
  \item Remove the first PCB from \texttt{sem.queue} and add it to the
        CPU wait queue 
  \item Enable interrupts
  \label{signal-return-disp}
  \item Return from the signal call
 \end{enumerate}
}

\newpage 

\subsection{Job A}
\renewcommand{\theenumi}{A\arabic{enumi}}
Job A has the task of adding all the integers from 1 to 30.
The answer is used by Job C which adds the result of this and Job
B.

\subsubsection{Pseudo-code}
\textsf{
\begin{enumerate}
\setlength{\itemsep}{0cm}
\item Set \$1 to \texttt{0}
\item Set \$2 to \texttt{0}
\item Add registers \$1 and \$2, putting the result in \$1
\label{joba-loop}
\item If \$2 equals 30 jump to \ref{joba-endloop}
\item Increment register \$2
\item Jump to \ref{joba-loop}
\item Store the contents of register \$1 in memory location \texttt{int\_sum}
\label{joba-endloop}
\item Call Signal(\texttt{int\_sum\_sem})
\item Terminate Job\footnote{Terminating a job involves disabling 
                            interrupts and jumping to \ref{disp-select}}
\end{enumerate}
}


\subsection{Job B}
\renewcommand{\theenumi}{B\arabic{enumi}}

Job B has the task of adding all the powers of two less than 30
(starting from $ 2^{1} $).  The answer is used by Job C which adds the
result of this and Job A.

\subsubsection{Pseudo-code}
\textsf{
\begin{enumerate}
\setlength{\itemsep}{0cm}
\item Set \$1 to \texttt{0}
\item Set \$2 to \texttt{1}
\item Add \$2 to itself, putting the result in \$2
\label{jobb-loop}
\item If \$2 is greater than 30 jump to \ref{jobb-endloop}
\item Add registers \$1 and \$2 putting the result in register \$1
\item Jump to \ref{jobb-loop}
\item Store the contents of register \$1 in memory location \texttt{two\_sum}
\label{jobb-endloop}
\item Call Signal(\texttt{two\_sum\_sem})
\item Terminate Job
\end{enumerate}
}

\newpage

\subsection{Job C}
\renewcommand{\theenumi}{C\arabic{enumi}}
Job C adds the results of Jobs A and B and places this result in 
\texttt{answer}.

\subsubsection{Pseudo-code}
\textsf{
\begin{enumerate}
\setlength{\itemsep}{0cm}
\item Wait(\texttt{two\_sum\_sem})
\item Get the content of memory location \texttt{two\_sum} and put it into
      register \$1
\item Wait(\texttt{int\_sum\_sem})
\item Get the content of memory location \texttt{int\_sum} and put it into
      register \$2
\item Add the contents of registers \$1 and \$2 place the result in register
      \$2.
\item Store the contents of register \$2 in memory location \texttt{answer}
\item Disable timer interrupts
\item Terminate Job.
\end{enumerate}
}

\section{Timer Interrupts}
Timer interrupts are caused by a hardware clock attached to the CPU that 
causes an interrupt at a regular rate. 

To reduce the complexity in this exercise it is assumed that every
pseudo-code instruction takes the same amount of time to execute (this
is not the case for CISC CPUs but is often the case for RISC CPUs). It
is further assumed that the interval between interrupts is the same as
the time it takes to execute 20 instructions.  This is much shorter
than a real operating system would use.  An operating system for the
REX boards might have a timeslice in the order of 50-500ms (50,000 -
500,000 instructions).


\section{Initialisation}
The system begins with 
\begin{itemize}
\setlength{\itemsep}{0cm}

\item All semaphores set to 0 (no processes on the queue, no resource
available)

\item The three jobs queued on the CPU wait queue such that the first
job to be removed from the queue will be Job A, the second Job B and
the last Job C.

\item The PCB for each job contains in the \texttt{\$ear} location an
address for the first instruction of the job and a value indicating
that previous interrupts were enabled.  The \texttt{\$sp} field in the
PCB of each job is set to the base of the stack for that job.

\item The \texttt{time\_used} fields in the PCBs are set to 0.

\item The initial value of \texttt{time\_slice} is 2.

\item Interrupts are disabled, with no pending interrupt.

\item The first instruction to be executed is \ref{tsc=0}
\end{itemize}


\section{Running the Simulator}

Run the program \verb+/home/201/bin/xmtk+ from the console of a Lab 1
machine (not a non-X remote login).  The program starts quite a few
windows; you will need to spread them out on the screen so that you
can see what is going on.

After you start the simulator, but before you execute the first
instruction, look carefully at the initial state.  Check the CPU
register values and the PCBs.  Follow the CPU wait queue (linked list)
from the variable \texttt{CPU\_wait\_Q} through the PCB \texttt{link}
fields.

Once you understand the basic layout single step the program. The
instruction executed will appear in the log window if you have it
open.  Any memory locations or CPU registers that have been changed
will turn red.  Identify the instruction executed in the pseudo-code
listings in this guide (or in the pop-up `code' window).  As you
progress through the code look at the next instruction and predict
what the effect of the instruction will be.  Execute the instruction
and follow the results carefully, making sure you understand what
happens at each step.  If you are confident that you understand a
group of instructions (e.g. the code for Job A once you have been
through it a couple of times) you can execute several instructions at
a time by using the run button.

When you understand the behaviour of the simulator with a timeslice of
2 rerun the simulation with a timeslice of 3.  Particularly notice
the behaviour at time 239 and the total number of instructions
required to complete the simulation.

\section{Questions}
\renewcommand{\theenumi}{\arabic{enumi}}
The following questions will help you get the most from this exercise.
Answer them to improve your understanding of what is happening during
the simulation and how it relates to a real multitasking kernel.

\begin{enumerate}
\item
Why are the initial values stored in the PCB for \texttt{\$ear} and
interrupt status not empty?

\item
Why does the \$1 field in PCB0 not change when instruction 
A3 (\verb_$1 = $1 + $2_) is executed?

%$

\item
Comment on the process exchange that happens around time 180.

\item
What is the meaning of the message ``Blocked interrupt''.  When will
the interrupt occur?

\item 
What is the CPU ``pending'' register used for?

\item 
Explain the role of the link field in the PCB.

\item
The CPU register \verb+ints_were+ stores the status of the interrupts
before the current interrupt occurred.  Why is this field needed.  

\item 

Imagine the following sequence of instructions:
\begin{enumerate}
\item Job B calls signal (the return address is put on the stack) but
      the timeslice ends before the signal routine returns.
\item The dispatcher chooses Job C.
\item Job C calls wait (the return address is placed on the stack).
\item Job C is suspended inside the wait subroutine. 
\item The dispatcher chooses Job B again.
\item Job B returns from the signal call by popping the item off the
      top of the stack and returning to that address.
\end{enumerate}

How does the system ensure that the return from subroutine executed by
Job B returns to its return address and not that for Job C (which was
the last one to be pushed onto the stack?

\item
There is no code in the dispatcher to change stacks.  How are stacks
changed?


\item
The \texttt{time\_used} variable does not record the exact amount of
time used by a job but is an approximation to it.  What units does the
\texttt{time\_used} variable variable have?  Sometimes the
\texttt{time\_used} variable is increments by 1 but the job has only
received part of a unit.  When is this?


\item
Compare the completion time of the 3 jobs when the timeslice is 2 and
3. Explain the change.  Why should a very long timeslice not be used?

\item 
If the dispatcher is returning to code that had interrupts enabled it
is essential that the interrupts are enabled at the same time the CPU
returns to the job that is running.  This is achieved through the use
of a return from interrupt (\texttt{'rfe'}) instruction.

A subtle bug would be introduced if the dispatcher was rewritten so
that this occurred in two separate steps, i.e. enable interrupts then
jump back to the job.  

What is this bug and what behaviour will occur? 
\end{enumerate}

Something to think about:

\begin{enumerate}
\item
Why do interrupts need to be disabled during the wait and signal code?
\end{enumerate}


\section{Extension}

Able students might be interested to compare the simulator used in
this exercise, which uses a RISC style architecture, with the
simulator \verb+/home/201/bin/xmtk-cisc+ which uses a CISC style
architecture.

\section{Glossary}

\begin{tabular}{lp{10cm}}
Word & Meaning\\ 

\hline \verb+Ints_were+ & This field corresponds to the WRAMP Old
Interrupt Enable (OIE) bit that is located in the CPU control register
(\texttt{\$cctrl}).  It holds the status of Interrupts (enabled or
disabled) before the current exception occurred.\\

PCB & Process Control Block. Space to save the context of a task or
process.\\

\verb+PC+ & Program Counter. Stores the address of the next
instruction to be executed.\\

Pseudo-code & Code for an imaginary machine, used for the sake of
example or instruction.\\
\end{tabular}

\thispagestyle{rcsfooters}
\pagestyle{rcsfooters}

\end{document}

