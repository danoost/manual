
\documentclass[a4paper,10pt]{article}
\setlength{\parindent}{0ex}
\setlength{\parskip}{1.5ex}
\usepackage[dvips]{graphicx}
\usepackage {epsfig}
\usepackage[a4paper, hmargin=25mm, vmargin=30mm, nohead]{geometry}


%INCLUDE OUR GLOBALS
\usepackage{rex201}
\usepackage{styles201}
\usepackage{ex201}


\begin{document}
\newcommand{\marks}[1]
{\begin{flushright}{\bf (#1 marks)}\end{flushright}}

\EXTESTHEADING{\IONO}{\IOTESTDATE}



\begin{enumerate}

%%WRAMPsim question

\item  In exercise 5 you used \program{WRAMPsim} to simulate the
execution of WRAMP instructions on a WRAMP data-path. Figure
\ref{fig:wrampblok} shows the architecture of the WRAMP CPU that
you used in the exercise. Although not shown on the diagram there are
control lines between the control unit and each of the components,
which are used to control the flow of data on the data-path. The
control signals for each of the components and their functionality is
defined in Tables \ref{table:signals} and
\ref{table:alu} of Appendix \ref{cntrl_sig_defn}. 

\begin{figure}[h]
\begin{center}
    \psfig{figure=datapath.eps, width=.8\linewidth}
    \caption{Data-path Architecture for WRAMP CPU}
    \label{fig:wrampblok}
  \end{center}
\end{figure}


\begin{enumerate} 

  \item Define the control signals necessary to fetch the next
  instruction to be executed and increment the program counter. If you
  use multiple control steps you should make sure you clearly indicate
  the control signals which are set for each individual control step.

  \marks{3}

  \item Define the control steps necessary to execute a JAL
  instruction. You can assume the instruction has already been fetched
  and the program counter has been incremented. Again you should
  clearly indicate in your answer which control signals are defined in
  each of the control steps.

  \marks{5} 

\end{enumerate}

\newpage
%% 25 X's Question
\item Figure \ref{sol_q3} contains a correct solution for Question 3
of Exercise 6 that asked you to write a program to output 25 ''X''s to
the serial port connected to the \hardware{terminal}. Appendix
\ref{org_sp_defn} defines the operation of the serial ports for this
question.

  \begin{enumerate}

  \item If lines 7 - 9 of this program were removed, would it
  still output 25 ''X''s to the \hardware{terminal} when run? If not, what
  would the likely output be? Why?

  \marks{4}

  \item What change(s) would have to be made to the program so that
  it would output 15 ''X''s (instead of 25) when run? On your answer
  you should clearly indicate the line numbers of the line(s) you have
  changed. 

  \marks{2}

  \item What changes would have to be made to the program so that it
  would output ''Y''s instead of ''X''s when  it was run? On your answer
  you should clearly indicate the line numbers of the line(s) you have
  changed. 

  \marks{2}

\end{enumerate}

%% END 25 X's Question

\begin{figure}[h]
\begin{small}
\begin{center}
\begin{tabular}{|p{6cm}|}
\hline
\begin{verbatim}
   1:	  .global main
   2:	  .text
   3:
   4:  main: ori  $8,  $0, 0x19
   5:        ori  $9,  $0, 0x58
   6:  loop: beqz $8,  endloop
   7:        lw   $11, 0x71003($0)
   8:        andi $11, $11, 0x2
   9:        beqz $11, loop
  10:        sw   $9,  0x71000($0)
  11:        subi $8,  $8, 1
  12:        j    loop
  13:  endloop:
  14:        jr $ra

\end{verbatim}
%% $
\\
\hline
\end{tabular}
\end{center}
\end{small}
\caption{Code for question 2}
\label{sol_q3}
\end{figure}

\newpage
\item In Question 5 of Exercise 6 you were asked to write a
program that continually reads a character from the serial port
connected to the \hardware{terminal}, converts all \emph{lowercase}
characters to \emph{uppercase} and outputs the character to the serial
port connected to the \hardware{Linux machine}. For example, if an 'a' is
the input then "A" is the output. If an "A" is the input then "A" is
the output. Figure \ref{q2_prog} contains a \emph{correct} solution
for this question. Appendix \ref{org_sp_defn} shows the format of the
status register used in the assignment and this solution.

\begin{figure}[h]
\begin{small}
\begin{center}
\begin{tabular}{|p{6cm}|}
\hline
\begin{verbatim}
   1:	.global main
   2:	.text
   3: main:
   4:       lw     $2,  0x71003($0)
   5:       andi   $2,  $2, 1
   6:       beqz   $2,  main
   7:       lw     $3,  0x71001($0)
   8:       sgei   $10, $3, 'a'
   9:       slei   $11, $3, 'z'
  10:       and    $10, $10, $11
  11:       beqz   $10, outch
  12:       subi   $3,  $3, 0x20
  13: outch:	  	
  14:       lw     $2,  0x70003($0)
  15:       andi   $2,  $2, 2
  16:       beqz   $2,  outch
  17:       sw     $3,  0x70000($0)
  18:       j      main
\end{verbatim}
\\
\hline
\end{tabular}
\end{center}
\end{small}
\caption{Code for question 3}
\label{q2_prog}
\end{figure}

\begin{enumerate} %%%%%%%sub question %%%%%%%%


\item What changes would be necessary to the program so that it reads
characters from the \hardware{Linux machine} and outputs characters to the
\hardware{terminal} ?

\marks{4}

\item What changes would need to be made to this program so swaps the
case of the characters typed on the \hardware{terminal} and outputs them
to the \hardware{Linux Machine}? For example, if an ``a'' is input on the
\hardware{terminal} then an ``A'' is output to the \hardware{Linux
machine}. If an ``A'' is the input then ``a'' is the output.

\marks{10}


\end{enumerate}

\end{enumerate}



\appendix
\newpage

\section{Definition of the WRAMP Control Signals for question 1} 
\label{cntrl_sig_defn}

\begin{table}[h]
\begin{center}
\begin{tabular}{|l|l|p{8cm}|}
\hline
\textbf{Component} & \textbf{Signal Name} & \textbf{Description} \\
\hline
Register File & \texttt{a\_out} & Causes the contents of the
register selected by \texttt{sel\_a} to be output onto the A bus. \\
\cline{2-3}
& \texttt{sel\_a} & Select which register will be output onto the A bus
if \texttt{a\_out} is asserted. \\
\cline{2-3}
& \texttt{b\_out} & Causes the contents of the
register selected by \texttt{sel\_b} to be output onto the B bus. \\
\cline{2-3}
& \texttt{sel\_b} & Select which register will be output onto the B bus
if \texttt{b\_out} is asserted. \\
\cline{2-3}
& \texttt{c\_in} & Causes the value from the C bus to be written
into the register selected by \texttt{sel\_c}.\\
\cline{2-3}
& \texttt{sel\_c} & Select which register to write the value from the C
bus into when the \texttt{c\_in} signal is asserted. \\
\hline
ALU & \texttt{alu\_out} & Causes the result of the current ALU function 
selected by \texttt{alu\_func} to be output to the C bus. \\
\cline{2-3}
& \texttt{alu\_func} & Defines the current operation that the ALU
should perform. ALU functions are defined in table~\ref{table:alu}. \\
\hline
Memory Interface & \texttt{mem\_read} & Causes the contents of the
memory address specified on the A bus to be read and output onto the C
bus. \\
\cline{2-3}
& \texttt{mem\_write} & Causes the value on the B bus to be written
into the memory address specified on the A bus. \\
\hline
Program Counter & \texttt{pc\_out} & Causes the contents of the PC
register to be output onto the A bus. \\
\cline{2-3}
& \texttt{pc\_in} & Causes the value on the C bus to be written into
the PC. \\
\hline
Instruction Register & \texttt{imm\_16\_out} & Causes the least
significant 16 bits of the IR to be output onto the B bus. \\
\cline{2-3}
& \texttt{imm\_20\_out} & Causes the least
significant 20 bits of the IR to be output onto the B bus. \\
\cline{2-3}
& \texttt{sign\_extend} & Causes the output from the IR to be sign
extended to 32bits. \\
\cline{2-3}
& \texttt{ir\_in} & Causes the value on the C bus to be written into
the IR. \\
\hline
Temporary Register & \texttt{temp\_out} & Causes the contents of the
temporary register to be output onto the A bus. \\
\cline{2-3}
& \texttt{temp\_in} & Causes the value on the C bus to be written into
the temporary register. \\
\hline
\end{tabular}
\end{center}
\caption{Descriptions of each of the control signals}
\label{table:signals}
\end{table}



\newpage
\begin{table}[h]
All arithmetic and test/set instructions have both signed and unsigned
variants. The unsigned variant is indicated by an instruction with a
'u' suffix. A singed variant treats all inputs as signed integers while
the unsigned variant treats inputs as unsigned integers.

\begin{center}
\begin{tabular}{|l|l|l|p{75mm}|}
\hline
\textbf{Type} & \textbf{Name} & \textbf{Function} 
& \textbf{Description} \\
\hline
Arithmetic & \texttt{add, addu} & A + B & Perform an integer
addition between A and B. \\
\cline{2-4}
& \texttt{sub, subu} & A - B & Perform an integer
subtraction between A and B. \\
\cline{2-4}
& \texttt{mult, multu} & A * B & Perform an
integer multiplication between A and B. \\
\cline{2-4}
& \texttt{div, divu} & A / B & Perform an integer
division between A and B. \\
\cline{2-4} 
& \texttt{rem, remu} & A $\bmod$ B & Obtain the remainder from an
integer division between A and B. \\
\hline
Bitwise & \texttt{sll} & A $<<$ B & Shift the value on A left by the number of
places specified by B. Fill with zeros. \\
\cline{2-4}
& \texttt{and} & A AND B & Perform a bitwise AND between A and B. \\
\cline{2-4}
& \texttt{srl} & A $>>$ B & Shift the value on A right by the number of places
specified by B. Fill with zeros. \\
\cline{2-4}
& \texttt{or} & A OR B & Perform a bitwise OR between A and B.\\
\cline{2-4}
& \texttt{sra} & A $>>$ B & Shift the value on A right by the number of places
specified by B. Fill with MSB.\\
\cline{2-4}
& \texttt{xor} & A XOR B & Perform a bitwise XOR between A and B. \\
\hline
Test/set & \texttt{slt, sltu} & out = 1 if ( A $<$ B) & Set out if A
is less than B\\
& & else out = 0 & \\
\cline{2-4}
& \texttt{sgt, sgtu} & out = 1 if ( A $>$ B) & Set out if A
is greater than B \\
& & else out = 0 & \\
\cline{2-4}
& \texttt{sle, sleu} & out = 1 if ( A $\le$ B) & Set out if A
is less than or equal to B\\
& & else out = 0 & \\
\cline{2-4}
& \texttt{sge, sgeu} & out = 1 if ( A $\ge$ B) & Set out if A
is greater than or equal to B\\
& & else out = 0 & \\
\cline{2-4}
& \texttt{seq, sequ} & out = 1 if ( A $=$ B) & Set out if A
is equal to B \\
& & else out = 0 & \\
\cline{2-4}
& \texttt{sne, sneu} & out = 1 if ( A $\neq$ B) & Set out if A
is not equal to B \\
& & else out = 0 & \\
\hline
Misc & \texttt{lhi} & out\tiny$_{[31...16]}$\normalsize~= B\tiny$_{[15...0]}$ &
Set the upper 16 bits of out to be the lower 16 \\
& & out\tiny$_{[15...0]}$\normalsize~= 0 & bits of B. Lower 16 bits of out set to zero. \\ 
\cline{2-4}
& \texttt{inc} & out = A + 1 & Increment A\\
\hline
\end{tabular}
\end{center}
\caption{ALU Operations}
\label{table:alu}
\end{table}




\newpage
\section{Details for the serial ports for Questions 2 and 3}
\label{org_sp_defn}



The REX board provides two serial interfaces, one of which is
connected to the Linux machine and the other is connected to the
terminal that should be sitting on the shelf above the board. 

For each of the serial interfaces there are 4 registers accessible to
the CPU. These registers are the transmit data register, the receive
data register, the status register and the control register.

The transmit data register holds the value that is to be sent out of
the serial port. The receive data register holds the value that has
been received in the serial port. The status register indicates if
there is a value in the receive data register and also if the value in
the transmit data register has been sent. The control register allows
the configuration of the serial port. For this exercise the control
register will have already been configured for you by the monitor so
it will not need to be altered. Each serial port has a base address
and the 4 registers for each serial port are expressed as an offset
from this address. The base addresses for each port are defined in
table~\ref{table:serialbase} and the offsets are defined in
table~\ref{table:serialoffset}. The format of the status register for
each of the serial devices is shown in table~\ref{table:serialstat}.

\begin{table}[h]
\begin{center}
\begin{tabular}{|l|l|}
\hline
\textbf{Port} & \textbf{Base Address} \\
\hline
Linux machine & 0x70000 \\ 
\hline
Terminal & 0x71000 \\
\hline
\end{tabular}
\end{center}
\caption{Base addresses for each serial port}
\label{table:serialbase}
\end{table}

\begin{table}[h]
\begin{center}
\begin{tabular}{|l|l|}
\hline
\textbf{Register} & \textbf{Address} \\
\hline
Transmit Data & Base + 0 \\ 
\hline
Receive Data & Base + 1 \\
\hline
Control & Base + 2 \\
\hline
Status & Base + 3 \\
\hline
\end{tabular}
\end{center}
\caption{Offsets for each register}
\label{table:serialoffset}
\end{table}

\begin{table}[h]
\begin{center}
\begin{tabular}{|l|l|}
\hline
\textbf{Bit} & \textbf{Function} \\
\hline
0 & Receive Data Ready \\
 & 1 if data in receive data register, 0 otherwise \\
\hline
1 & Transmit Data Sent \\
 & 1 if ready for next character, 0 if data is still being transmitted  \\
\hline
\end{tabular}
\end{center}
\caption{Status register format}
\label{table:serialstat}
\end{table}


\end{document}




